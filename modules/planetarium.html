<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–õ–ê–ù–ï–¢–ê–†–ò–ô ‚Ä¢ –°–¢–ê–ù–¶–ò–ò ‚Ä¢ –í–´–†–ê–ë–û–¢–ö–ê</title>
    <!-- Three.js –∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –º–æ–¥—É–ª–∏ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0310;
            font-family: 'VT323', monospace;
            color: #ffaa00;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: hidden;
        }
        .constructor-card {
            width: 1200px;
            height: 800px;
            pointer-events: all;
            z-index: 2000;
        }
        .constructor-frame {
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #ffaa00;
            box-shadow: 0 0 20px #cc8800, inset 0 0 15px #442200;
            padding: 8px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .constructor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 0 4px;
        }
        .constructor-title {
            color: #ffff88;
            font-size: 28px;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 5px #ffaa00;
            cursor: help;
            border-bottom: 1px dashed #ffaa00;
        }
        .button-group {
            display: flex;
            gap: 6px;
        }
        .btn-small {
            background: rgba(40, 30, 10, 0.95);
            border: 2px solid #ffaa00;
            color: #ffff88;
            font-family: 'VT323', monospace;
            font-size: 24px;
            padding: 2px 20px;
            cursor: pointer;
            box-shadow: 0 0 6px #cc8800;
            transition: 0.1s;
            letter-spacing: 2px;
        }
        .btn-small:hover {
            background: rgba(80, 50, 20, 0.95);
            border-color: #ffff88;
            box-shadow: 0 0 10px #ffaa00;
        }
        .btn-small.reset {
            background: rgba(60, 20, 20, 0.95);
        }
        .btn-small.station {
            background: rgba(20, 40, 60, 0.95);
        }
        .constructor-canvas {
            flex: 1;
            position: relative;
            background: rgba(10, 5, 0, 0.9);
            border: 2px solid #ffaa00;
            overflow: hidden;
        }
        .stats-panel {
            display: flex;
            flex-wrap: wrap;
            margin-top: 8px;
            padding: 8px 4px;
            border-top: 1px dashed #ffaa00;
            font-size: 18px;
            gap: 16px;
            background: rgba(0,0,0,0.6);
            justify-content: space-around;
        }
        .stat-item {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: help;
        }
        .stat-label {
            color: #cc8800;
        }
        .stat-value {
            color: #ffff88;
            font-weight: bold;
            letter-spacing: 3px;
        }
        .tooltip {
            position: absolute;
            background: rgba(10, 5, 0, 0.98);
            border: 2px solid #ffaa00;
            padding: 8px 12px;
            font-size: 18px;
            color: #ffff88;
            white-space: nowrap;
            pointer-events: none;
            box-shadow: 0 0 15px #cc8800;
            z-index: 3000;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.15s;
            border-radius: 0;
            font-family: 'VT323', monospace;
        }
        .tooltip.active {
            opacity: 1;
        }
        .full-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            border: 2px solid #ffaa00;
            padding: 8px 16px;
            color: #ffff88;
            font-size: 24px;
            letter-spacing: 2px;
            box-shadow: 0 0 20px #cc8800;
            z-index: 3500;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            text-transform: uppercase;
        }
        .full-message.show {
            opacity: 1;
        }
        .ai-stats-data {
            display: none;
        }
        /* –ö–∞—Å—Ç–æ–º–Ω—ã–π —Ç—É–ª—Ç–∏–ø –¥–ª—è –≤—Å–µ–≥–æ */
        #hover-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 2px solid #ffaa00;
            font-family: 'VT323', monospace;
            font-size: 18px;
            padding: 8px 12px;
            pointer-events: none;
            z-index: 10000;
            box-shadow: 0 0 20px #cc8800;
            white-space: nowrap;
            display: none;
            border-radius: 0;
            color: #ffff88;
        }
        #hover-tooltip table {
            border-collapse: collapse;
        }
        #hover-tooltip td {
            padding: 2px 8px;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è —Ä–µ—Å—É—Ä—Å–Ω—ã—Ö –ø–ª–∞—à–µ–∫ (—Å –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º) */
        .resource-tag {
            font-family: 'Myriad Pro', 'Myriad', 'Segoe UI', sans-serif;
            font-weight: bold;
            font-size: 10px;
            color: white;
            text-transform: uppercase;
            text-shadow: 0 0 8px currentColor, 1px 1px 2px black;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            border-radius: 4px;
            padding: 2px 4px;
            white-space: nowrap;
            pointer-events: none;
            letter-spacing: 0.5px;
            backdrop-filter: blur(1px);
            filter: saturate(1.5);
            position: relative;
            overflow: hidden;
            z-index: 10;
        }
        .resource-tag span {
            position: relative;
            z-index: 12;
        }
        .resource-tag .progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: rgba(0, 255, 0, 0.5);
            width: 0%;
            z-index: 11;
            transition: width 0.2s linear;
            pointer-events: none;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è —Å—Ç–∞–Ω—Ü–∏–π */
        .station-label {
            font-family: 'VT323', monospace;
            font-size: 12px;
            color: #88ddff;
            text-shadow: 0 0 8px #00aaff, 1px 1px 1px black;
            background: rgba(0, 40, 80, 0.9);
            border: 2px solid #88ddff;
            border-radius: 12px;
            padding: 2px 8px;
            white-space: nowrap;
            pointer-events: none;
            letter-spacing: 1px;
            backdrop-filter: blur(2px);
        }
        /* –û—Ä–±–∏—Ç–∞–ª—å–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∏ */
        .orbit-label {
            font-family: sans-serif;
            font-size: 10px;
            color: #ffff88;
            text-shadow: 0 0 5px currentColor;
            background: rgba(0,0,0,0.5);
            padding: 2px 4px;
            border-radius: 2px;
            white-space: nowrap;
            pointer-events: none;
            border: 1px solid currentColor;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>
    <div class="constructor-card" id="planetarium-card">
        <div class="constructor-frame">
            <div class="constructor-header">
                <span class="constructor-title" id="planetarium-title">–ü–õ–ê–ù–ï–¢–ê–†–ò–ô</span>
                <div class="button-group">
                    <button class="btn-small" id="planetarium-add-btn" title="‚ûï —É—Ä–æ–≤–µ–Ω—å +">‚ûï</button>
                    <button class="btn-small reset" id="planetarium-reset-btn" title="‚àí —É—Ä–æ–≤–µ–Ω—å ‚àí">‚àí</button>
                    <button class="btn-small station" id="station-add-btn" title="üõ∞Ô∏è –ø–æ–≤–µ—Å–∏—Ç—å —Å—Ç–∞–Ω—Ü–∏—é">üõ∞Ô∏è</button>
                </div>
            </div>
            <div class="constructor-canvas" id="planetarium-canvas"></div>
            <div class="stats-panel" id="planetarium-stats-panel"></div>
        </div>
        <div class="tooltip" id="planetarium-tooltip"></div>
        <div class="full-message" id="planetarium-full-message"></div>
        <div class="ai-stats-data" id="planetarium-ai-data"></div>
    </div>
    <div id="hover-tooltip"></div>

    <script>
        (function() {
            // ==================== –ù–ê–°–¢–†–û–ô–ö–ò ====================
            const MAX_LEVEL = 7;
            const BASE_RADIUS = 5.5;
            const GROWTH_FACTOR = 1.15;
            const SPHERE_RADIUS = 4.0;
            const TAG_RADIUS = SPHERE_RADIUS + 1.5; // —É–¥–ª–∏–Ω—ë–Ω–Ω—ã–µ –≤—ã–Ω–æ—Å–∫–∏
            const MAX_STATIONS = 1500;               // –º–∞–∫—Å–∏–º—É–º —Å—Ç–∞–Ω—Ü–∏–π
            
            const ORBIT_COLORS = [0xaaaaaa, 0x44aaff, 0x3366ff, 0x33cc33, 0xffaa00, 0xff6600, 0xff0000];
            
            // –ù–∞–∑–≤–∞–Ω–∏—è —É—Ä–æ–≤–Ω–µ–π –Ω–∞ –ø—è—Ç–∏ —è–∑—ã–∫–∞—Ö
            const LEVEL_NAMES_MULTI = [
                ["–ê–°–¢–ï–†–û–ò–î–´", "ASTEROIDS", "Â∞èË°åÊòüÂ∏¶", "Â∞èÊÉëÊòüÂ∏Ø", "ASTEROIDES"],
                ["–ù–ò–ó–ö–ê–Ø", "LOW G", "‰ΩéÈáçÂäõ", "‰ΩéÈáçÂäõ", "BAJA G"],
                ["–°–†–ï–î–ù–Ø–Ø", "MEDIUM G", "‰∏≠ÈáçÂäõ", "‰∏≠ÈáçÂäõ", "MEDIA G"],
                ["–ò–î–ï–ê–õ–¨–ù–ê–Ø", "IDEAL G", "ÁêÜÊÉ≥ÈáçÂäõ", "ÁêÜÊÉ≥ÈáçÂäõ", "G IDEAL"],
                ["–ü–û–í–´–®–ï–ù–ù–ê–Ø", "HIGH G", "È´òÈáçÂäõ", "È´òÈáçÂäõ", "ALTA G"],
                ["–í–´–°–û–ö–ê–Ø", "VERY HIGH", "ÈùûÂ∏∏È´ò", "ÈùûÂ∏∏„Å´È´ò„ÅÑ", "MUY ALTA"],
                ["–°–ú–ï–†–¢–ï–õ–¨–ù–ê–Ø", "DEADLY", "Ëá¥ÂëΩ", "Ëá¥ÂëΩÁöÑ", "MORTAL"]
            ];
            
            // –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Ä–µ—Å—É—Ä—Å–æ–≤
            const RESOURCES = [
                "–í–æ–¥–æ—Ä–æ–¥", "–ì–µ–ª–∏–π-3", "–î–µ–π—Ç–µ—Ä–∏–π", "–¢—Ä–∏—Ç–∏–π", "–õ–∏—Ç–∏–π", "–ë–µ—Ä–∏–ª–ª–∏–π", "–ë–æ—Ä", 
                "–£–≥–ª–µ—Ä–æ–¥", "–ê–∑–æ—Ç", "–ö–∏—Å–ª–æ—Ä–æ–¥", "–§—Ç–æ—Ä", "–ù–µ–æ–Ω", "–ù–∞—Ç—Ä–∏–π", "–ú–∞–≥–Ω–∏–π", 
                "–ê–ª—é–º–∏–Ω–∏–π", "–ö—Ä–µ–º–Ω–∏–π", "–§–æ—Å—Ñ–æ—Ä", "–°–µ—Ä–∞", "–•–ª–æ—Ä", "–ê—Ä–≥–æ–Ω", "–ö–∞–ª–∏–π", 
                "–ö–∞–ª—å—Ü–∏–π", "–°–∫–∞–Ω–¥–∏–π", "–¢–∏—Ç–∞–Ω", "–í–∞–Ω–∞–¥–∏–π", "–•—Ä–æ–º", "–ú–∞—Ä–≥–∞–Ω–µ—Ü", "–ñ–µ–ª–µ–∑–æ", 
                "–ö–æ–±–∞–ª—å—Ç", "–ù–∏–∫–µ–ª—å", "–ú–µ–¥—å", "–¶–∏–Ω–∫", "–ì–∞–ª–ª–∏–π", "–ì–µ—Ä–º–∞–Ω–∏–π", "–ú—ã—à—å—è–∫", 
                "–°–µ–ª–µ–Ω", "–ë—Ä–æ–º", "–ö—Ä–∏–ø—Ç–æ–Ω", "–†—É–±–∏–¥–∏–π", "–°—Ç—Ä–æ–Ω—Ü–∏–π", "–ò—Ç—Ç—Ä–∏–π", "–¶–∏—Ä–∫–æ–Ω–∏–π", 
                "–ù–∏–æ–±–∏–π", "–ú–æ–ª–∏–±–¥–µ–Ω", "–†—É—Ç–µ–Ω–∏–π", "–†–æ–¥–∏–π", "–ü–∞–ª–ª–∞–¥–∏–π", "–°–µ—Ä–µ–±—Ä–æ", 
                "–ö–∞–¥–º–∏–π", "–ò–Ω–¥–∏–π", "–û–ª–æ–≤–æ", "–°—É—Ä—å–º–∞", "–¢–µ–ª–ª—É—Ä", "–ô–æ–¥", "–ö—Å–µ–Ω–æ–Ω", 
                "–¶–µ–∑–∏–π", "–ë–∞—Ä–∏–π", "–õ–∞–Ω—Ç–∞–Ω", "–¶–µ—Ä–∏–π", "–ü—Ä–∞–∑–µ–æ–¥–∏–º", "–ù–µ–æ–¥–∏–º", "–°–∞–º–∞—Ä–∏–π", 
                "–ï–≤—Ä–æ–ø–∏–π", "–ì–∞–¥–æ–ª–∏–Ω–∏–π", "–¢–µ—Ä–±–∏–π", "–î–∏—Å–ø—Ä–æ–∑–∏–π", "–ì–æ–ª—å–º–∏–π", "–≠—Ä–±–∏–π", 
                "–¢—É–ª–∏–π", "–ò—Ç—Ç–µ—Ä–±–∏–π", "–õ—é—Ç–µ—Ü–∏–π", "–ì–∞—Ñ–Ω–∏–π", "–¢–∞–Ω—Ç–∞–ª", "–í–æ–ª—å—Ñ—Ä–∞–º", 
                "–†–µ–Ω–∏–π", "–û—Å–º–∏–π", "–ò—Ä–∏–¥–∏–π", "–ü–ª–∞—Ç–∏–Ω–∞", "–ó–æ–ª–æ—Ç–æ", "–†—Ç—É—Ç—å", "–¢–∞–ª–ª–∏–π", 
                "–°–≤–∏–Ω–µ—Ü", "–í–∏—Å–º—É—Ç", "–¢–æ—Ä–∏–π", "–£—Ä–∞–Ω", "–ü–ª—É—Ç–æ–Ω–∏–π"
            ];

            // –¶–≤–µ—Ç–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–µ—Å—É—Ä—Å–∞ (—è—Ä–∫–∏–µ)
            const RESOURCE_COLORS = {
                "–í–æ–¥–æ—Ä–æ–¥": "#aaccff", "–ì–µ–ª–∏–π-3": "#ffff99", "–î–µ–π—Ç–µ—Ä–∏–π": "#cce5ff", "–¢—Ä–∏—Ç–∏–π": "#b3d9ff",
                "–õ–∏—Ç–∏–π": "#ffcc99", "–ë–µ—Ä–∏–ª–ª–∏–π": "#ccffcc", "–ë–æ—Ä": "#ffb3b3", "–£–≥–ª–µ—Ä–æ–¥": "#999999",
                "–ê–∑–æ—Ç": "#99ccff", "–ö–∏—Å–ª–æ—Ä–æ–¥": "#99ffff", "–§—Ç–æ—Ä": "#ccff99", "–ù–µ–æ–Ω": "#ff99cc",
                "–ù–∞—Ç—Ä–∏–π": "#ffff99", "–ú–∞–≥–Ω–∏–π": "#ccff99", "–ê–ª—é–º–∏–Ω–∏–π": "#ccccff", "–ö—Ä–µ–º–Ω–∏–π": "#c0c0c0",
                "–§–æ—Å—Ñ–æ—Ä": "#ff9966", "–°–µ—Ä–∞": "#ffff66", "–•–ª–æ—Ä": "#99ff99", "–ê—Ä–≥–æ–Ω": "#cc99ff",
                "–ö–∞–ª–∏–π": "#ffb3ff", "–ö–∞–ª—å—Ü–∏–π": "#b3b3ff", "–°–∫–∞–Ω–¥–∏–π": "#b3ffb3", "–¢–∏—Ç–∞–Ω": "#b3b3b3",
                "–í–∞–Ω–∞–¥–∏–π": "#b3b3b3", "–•—Ä–æ–º": "#b3b3b3", "–ú–∞—Ä–≥–∞–Ω–µ—Ü": "#b3b3b3", "–ñ–µ–ª–µ–∑–æ": "#ff9966",
                "–ö–æ–±–∞–ª—å—Ç": "#6666ff", "–ù–∏–∫–µ–ª—å": "#c0c0c0", "–ú–µ–¥—å": "#ff9933", "–¶–∏–Ω–∫": "#99cc99",
                "–ì–∞–ª–ª–∏–π": "#b3b3b3", "–ì–µ—Ä–º–∞–Ω–∏–π": "#b3b3b3", "–ú—ã—à—å—è–∫": "#b3b3b3", "–°–µ–ª–µ–Ω": "#b3b3b3",
                "–ë—Ä–æ–º": "#ff6666", "–ö—Ä–∏–ø—Ç–æ–Ω": "#b3b3b3", "–†—É–±–∏–¥–∏–π": "#b3b3b3", "–°—Ç—Ä–æ–Ω—Ü–∏–π": "#b3b3b3",
                "–ò—Ç—Ç—Ä–∏–π": "#b3b3b3", "–¶–∏—Ä–∫–æ–Ω–∏–π": "#b3b3b3", "–ù–∏–æ–±–∏–π": "#b3b3b3", "–ú–æ–ª–∏–±–¥–µ–Ω": "#b3b3b3",
                "–†—É—Ç–µ–Ω–∏–π": "#b3b3b3", "–†–æ–¥–∏–π": "#b3b3b3", "–ü–∞–ª–ª–∞–¥–∏–π": "#b3b3b3", "–°–µ—Ä–µ–±—Ä–æ": "#e6e6e6",
                "–ö–∞–¥–º–∏–π": "#b3b3b3", "–ò–Ω–¥–∏–π": "#b3b3b3", "–û–ª–æ–≤–æ": "#b3b3b3", "–°—É—Ä—å–º–∞": "#b3b3b3",
                "–¢–µ–ª–ª—É—Ä": "#b3b3b3", "–ô–æ–¥": "#cc99ff", "–ö—Å–µ–Ω–æ–Ω": "#b3b3b3", "–¶–µ–∑–∏–π": "#ffd966",
                "–ë–∞—Ä–∏–π": "#b3b3b3", "–õ–∞–Ω—Ç–∞–Ω": "#b3b3b3", "–¶–µ—Ä–∏–π": "#b3b3b3", "–ü—Ä–∞–∑–µ–æ–¥–∏–º": "#b3b3b3",
                "–ù–µ–æ–¥–∏–º": "#b3b3b3", "–°–∞–º–∞—Ä–∏–π": "#b3b3b3", "–ï–≤—Ä–æ–ø–∏–π": "#b3b3b3", "–ì–∞–¥–æ–ª–∏–Ω–∏–π": "#b3b3b3",
                "–¢–µ—Ä–±–∏–π": "#b3b3b3", "–î–∏—Å–ø—Ä–æ–∑–∏–π": "#b3b3b3", "–ì–æ–ª—å–º–∏–π": "#b3b3b3", "–≠—Ä–±–∏–π": "#b3b3b3",
                "–¢—É–ª–∏–π": "#b3b3b3", "–ò—Ç—Ç–µ—Ä–±–∏–π": "#b3b3b3", "–õ—é—Ç–µ—Ü–∏–π": "#b3b3b3", "–ì–∞—Ñ–Ω–∏–π": "#b3b3b3",
                "–¢–∞–Ω—Ç–∞–ª": "#b3b3b3", "–í–æ–ª—å—Ñ—Ä–∞–º": "#b3b3b3", "–†–µ–Ω–∏–π": "#b3b3b3", "–û—Å–º–∏–π": "#b3b3b3",
                "–ò—Ä–∏–¥–∏–π": "#b3b3b3", "–ü–ª–∞—Ç–∏–Ω–∞": "#e6e6e6", "–ó–æ–ª–æ—Ç–æ": "#ffcc66", "–†—Ç—É—Ç—å": "#b3b3b3",
                "–¢–∞–ª–ª–∏–π": "#b3b3b3", "–°–≤–∏–Ω–µ—Ü": "#808080", "–í–∏—Å–º—É—Ç": "#ffb3b3", "–¢–æ—Ä–∏–π": "#b3b3b3",
                "–£—Ä–∞–Ω": "#99cc66", "–ü–ª—É—Ç–æ–Ω–∏–π": "#b3b3b3"
            };
            
            // ==================== –¢–ò–ü–´ –ü–õ–ê–ù–ï–¢ ====================
            const PLANET_TYPES = [
                { name: 'Terran', colors: [0x2288ff, 0x44aaff, 0x88ccff, 0x44aa44, 0x66bb66, 0x88dd88, 0xaa8866, 0xccaa88, 0xeeddbb, 0xffffff, 0xeeeeee, 0xcccccc] },
                { name: 'Martian', colors: [0xaa4400, 0xcc6600, 0xee8822, 0x882200, 0xaa4422, 0xcc6644, 0x552200, 0x773300, 0x994411] },
                { name: 'Jovian', colors: [0xeedd99, 0xffcc88, 0xffaa66, 0xccaa88, 0xbb9977, 0xaa8866, 0x886644, 0x775533, 0x664422, 0xffffff, 0xeeeeee, 0xcccccc] },
                { name: 'Neptunian', colors: [0x3366cc, 0x4477dd, 0x5588ee, 0x2255aa, 0x3366bb, 0x4477cc, 0x114488, 0x225599, 0x3366aa, 0xffffff, 0xeeeeee, 0xcccccc] },
                { name: 'Volcanic', colors: [0x883322, 0xaa5533, 0xcc7744, 0x442211, 0x663322, 0x884433, 0xff6600, 0xff8833, 0xffaa44, 0x331100, 0x552200, 0x773300] }
            ];
            
            // ==================== –°–û–°–¢–û–Ø–ù–ò–ï ====================
            let scene, camera, renderer, labelRenderer, controls;
            let planetGroup = new THREE.Group();
            let sphereMesh;
            let particles;
            let orbitLines = [];
            let orbitLabels = [];
            let resourceTags = [];
            let tagColliders = [];
            let tagLines = [];
            let satellites = [];
            let currentLevel = 4;
            let currentSeed = Date.now();
            let time = 0;
            
            // –ù–æ–≤—ã–µ –º–∞—Å—Å–∏–≤—ã –¥–ª—è —Å—Ç–∞–Ω—Ü–∏–π
            let stations = [];           // { mesh, label, collider, data }
            let stationsCount = 0;
            
            // –î–∞–Ω–Ω—ã–µ –¥–ª—è —Ç—É–ª—Ç–∏–ø–∞
            const hoverTooltip = document.getElementById('hover-tooltip');
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            const canvasDiv = document.getElementById('planetarium-canvas');
            const titleSpan = document.getElementById('planetarium-title');
            const statsPanel = document.getElementById('planetarium-stats-panel');
            const tooltipDiv = document.getElementById('planetarium-tooltip');
            const fullMessageDiv = document.getElementById('planetarium-full-message');
            const aiDataDiv = document.getElementById('planetarium-ai-data');
            
            // –†–µ—Å—É—Ä—Å—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è
            let currentResources = [];
            
            // ==================== –®–£–ú–û–í–´–ï –§–£–ù–ö–¶–ò–ò ====================
            let p = [];
            function initPermutation(seed) {
                let rng = function() { seed = (seed * 1664525 + 1013904223) % 4294967296; return (seed / 4294967296); };
                p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 255; i > 0; i--) { const j = Math.floor(rng() * (i + 1)); [p[i], p[j]] = [p[j], p[i]]; }
                for (let i = 0; i < 256; i++) p.push(p[i]);
            }
            
            function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            function grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            
            function noise(x, y, z) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = fade(x), v = fade(y), w = fade(z);
                const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;
                return lerp(lerp(lerp(grad(p[AA], x, y, z), grad(p[BA], x-1, y, z), u), lerp(grad(p[AB], x, y-1, z), grad(p[BB], x-1, y-1, z), u), v), lerp(lerp(grad(p[AA+1], x, y, z-1), grad(p[BA+1], x-1, y, z-1), u), lerp(grad(p[AB+1], x, y-1, z-1), grad(p[BB+1], x-1, y-1, z-1), u), v), w);
            }
            
            function lerp(a, b, t) { return a + t * (b - a); }
            
            function turbulence(x, y, z, octaves = 7) {
                let f = 0, amp = 1;
                for (let i = 0; i < octaves; i++) { f += amp * noise(x, y, z); x *= 2.03; y *= 2.01; z *= 2.02; amp *= 0.5; }
                return f;
            }
            
            // ==================== –ì–ï–ù–ï–†–ê–¶–ò–Ø –¢–ï–ö–°–¢–£–†–´ –ü–õ–ê–ù–ï–¢–´ ====================
            function generatePlanetTexture(seed, palette) {
                initPermutation(seed);
                const width = 1024, height = 512;
                const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;
                const numColors = palette.length;
                const timeOffset = Math.random() * 1000;
                
                for (let y = 0; y < height; y++) {
                    const v = y / height, phi = v * Math.PI;
                    for (let x = 0; x < width; x++) {
                        const u = x / width, theta = u * 2 * Math.PI;
                        const px = Math.sin(phi) * Math.cos(theta), py = Math.sin(phi) * Math.sin(theta), pz = Math.cos(phi);
                        let value = turbulence(px, py, pz, 7);
                        value = (value + 1.5) * 0.4; value = Math.max(0, Math.min(1, value));
                        const idx = Math.floor(value * (numColors - 1));
                        const color = palette[idx] || palette[palette.length-1];
                        const r = (color >> 16) & 255, g = (color >> 8) & 255, b = color & 255;
                        const pos = (y * width + x) * 4;
                        data[pos] = r; data[pos+1] = g; data[pos+2] = b; data[pos+3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0);
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.ClampToEdgeWrapping;
                return texture;
            }
            
            // ==================== –°–û–ó–î–ê–ù–ò–ï –°–§–ï–†–´ ====================
            function createSphere(seed, palette) {
                if (sphereMesh) planetGroup.remove(sphereMesh);
                const texture = generatePlanetTexture(seed, palette);
                const material = new THREE.ShaderMaterial({
                    uniforms: { map: { value: texture }, aberrationStrength: { value: 0.002 } },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                    fragmentShader: `uniform sampler2D map; uniform float aberrationStrength; varying vec2 vUv; void main() { float shift = aberrationStrength; vec2 redUv = vec2(vUv.x + shift, vUv.y); vec2 blueUv = vec2(vUv.x - shift, vUv.y); float r = texture2D(map, redUv).r; float g = texture2D(map, vUv).g; float b = texture2D(map, blueUv).b; gl_FragColor = vec4(r, g, b, 1.0); }`,
                    side: THREE.DoubleSide
                });
                const geometry = new THREE.SphereGeometry(SPHERE_RADIUS, 128, 64);
                sphereMesh = new THREE.Mesh(geometry, material);
                planetGroup.add(sphereMesh);
                return sphereMesh;
            }
            
            // ==================== –ß–ê–°–¢–ò–¶–´ (–°–¢–ê–¢–ò–ß–ù–´) ====================
            function createParticles(count = 20000, palette) {
                if (particles) planetGroup.remove(particles);
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const numColors = palette.length;
                
                for (let i = 0; i < count; i++) {
                    const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                    const x = Math.sin(phi) * Math.cos(theta), y = Math.sin(phi) * Math.sin(theta), z = Math.cos(phi);
                    positions[i*3] = x * SPHERE_RADIUS; positions[i*3+1] = y * SPHERE_RADIUS; positions[i*3+2] = z * SPHERE_RADIUS;
                    let val = turbulence(x, y, z, 7); val = (val + 1.5) * 0.4; val = Math.max(0, Math.min(1, val));
                    const idx = Math.floor(val * (numColors - 1));
                    const col = palette[idx] || palette[palette.length-1];
                    colors[i*3] = ((col >> 16) & 255) / 255; colors[i*3+1] = ((col >> 8) & 255) / 255; colors[i*3+2] = (col & 255) / 255;
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const canvas = document.createElement('canvas'); canvas.width = 8; canvas.height = 8;
                const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(4, 4, 3, 0, 2*Math.PI); ctx.fill();
                const pointTexture = new THREE.CanvasTexture(canvas);
                
                const material = new THREE.PointsMaterial({ size: 0.12, map: pointTexture, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, sizeAttenuation: true });
                particles = new THREE.Points(geometry, material);
                particles.frustumCulled = true;
                planetGroup.add(particles);
                return particles;
            }
            
            // ==================== –ü–õ–ê–®–ö–ò –° –†–ï–°–£–†–°–ê–ú–ò (—Å –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º) ====================
            function createResourceTags(numTags = 10) {
                // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ
                resourceTags.forEach(tag => planetGroup.remove(tag));
                tagColliders.forEach(c => planetGroup.remove(c));
                tagLines.forEach(line => planetGroup.remove(line));
                resourceTags = [];
                tagColliders = [];
                tagLines = [];
                
                const phi = Math.PI * (3 - Math.sqrt(5));
                
                for (let i = 0; i < numTags; i++) {
                    const y = 1 - (i / (numTags - 1)) * 2;
                    const radiusAtY = Math.sqrt(1 - y * y);
                    const theta = phi * i;
                    const x = Math.cos(theta) * radiusAtY;
                    const z = Math.sin(theta) * radiusAtY;
                    
                    const tagPos = new THREE.Vector3(x * TAG_RADIUS, y * TAG_RADIUS, z * TAG_RADIUS);
                    const surfacePos = new THREE.Vector3(x * SPHERE_RADIUS, y * SPHERE_RADIUS, z * SPHERE_RADIUS);
                    
                    const resName = RESOURCES[Math.floor(Math.random() * RESOURCES.length)];
                    const amount = Math.floor(Math.random() * 137) + 1;
                    
                    const pricePerUnit = (Math.random() * 50 + 10).toFixed(2);
                    const volume = Math.floor(Math.random() * 1000) + 100;
                    const extractionRate = (Math.random() * 20 + 1).toFixed(1);
                    const depth = (Math.random() * 1000 + 50).toFixed(0);
                    
                    const textColor = RESOURCE_COLORS[resName] || "#ffffff";
                    
                    // –°–æ–∑–¥–∞–µ–º div —Å –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º –≤–Ω—É—Ç—Ä–∏
                    const div = document.createElement('div');
                    div.className = 'resource-tag';
                    div.style.borderColor = textColor;
                    div.style.color = textColor;
                    div.innerHTML = `<span>${resName.toUpperCase()} ${amount}</span><div class="progress-bar" style="background: rgba(0,255,0,0.5); width:0%;"></div>`;
                    
                    const label = new THREE.CSS2DObject(div);
                    label.position.copy(tagPos);
                    label.userData = {
                        resource: resName,
                        amount: amount,
                        price: pricePerUnit,
                        volume: volume,
                        rate: extractionRate,
                        depth: depth,
                        color: textColor,
                        index: i,
                        extractionActive: false,   // —Ñ–ª–∞–≥ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤—ã—Ä–∞–±–æ—Ç–∫–∏
                        extractionInterval: null,
                        extractionStart: 0,
                        progressElement: div.querySelector('.progress-bar')
                    };
                    
                    planetGroup.add(label);
                    resourceTags.push(label);
                    
                    const colliderGeo = new THREE.SphereGeometry(0.3, 8, 8);
                    const colliderMat = new THREE.MeshBasicMaterial({ visible: false });
                    const collider = new THREE.Mesh(colliderGeo, colliderMat);
                    collider.position.copy(tagPos);
                    collider.userData = { tagIndex: i, type: 'resource' };
                    planetGroup.add(collider);
                    tagColliders.push(collider);
                    
                    const points = [surfacePos, tagPos];
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const colorHex = parseInt(textColor.slice(1), 16);
                    const lineMaterial = new THREE.LineBasicMaterial({ color: colorHex });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    planetGroup.add(line);
                    tagLines.push(line);
                    
                    const circleGeo = new THREE.SphereGeometry(0.1, 8, 8);
                    const circleMat = new THREE.MeshBasicMaterial({ color: colorHex });
                    const circle = new THREE.Mesh(circleGeo, circleMat);
                    circle.position.copy(surfacePos);
                    planetGroup.add(circle);
                    tagLines.push(circle);
                }
            }
            
            // ==================== –û–†–ë–ò–¢–´ –ò –ü–û–î–ü–ò–°–ò ====================
            function createOrbits() {
                orbitLines.forEach(line => planetGroup.remove(line));
                orbitLabels.forEach(label => planetGroup.remove(label));
                orbitLines = []; orbitLabels = [];
                
                for (let i = 0; i < MAX_LEVEL; i++) {
                    const radius = BASE_RADIUS * Math.pow(GROWTH_FACTOR, i);
                    const color = ORBIT_COLORS[i];
                    
                    // –õ–∏–Ω–∏—è –æ—Ä–±–∏—Ç—ã
                    const points = [];
                    for (let j = 0; j <= 128; j++) {
                        const angle = (j / 128) * Math.PI * 2;
                        points.push(new THREE.Vector3(radius * Math.cos(angle), 0, radius * Math.sin(angle)));
                    }
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ color: color });
                    const line = new THREE.LineLoop(geometry, material);
                    line.userData.level = i + 1;
                    planetGroup.add(line);
                    orbitLines.push(line);
                    
                    // –ü–æ–¥–ø–∏—Å–∏ (4 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
                    const labelAngles = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
                    const languages = LEVEL_NAMES_MULTI[i];
                    
                    for (let k = 0; k < labelAngles.length; k++) {
                        const angle = labelAngles[k];
                        const langIndex = k % languages.length;
                        const text = languages[langIndex];
                        
                        const offset = 0.3;
                        const x = (radius + offset) * Math.cos(angle);
                        const z = (radius + offset) * Math.sin(angle);
                        
                        const div = document.createElement('div');
                        div.className = 'orbit-label';
                        div.textContent = text;
                        div.style.color = '#' + color.toString(16).padStart(6, '0');
                        div.style.borderColor = '#' + color.toString(16).padStart(6, '0');
                        
                        const label = new THREE.CSS2DObject(div);
                        label.position.set(x, 0, z);
                        label.userData = { level: i + 1 };
                        planetGroup.add(label);
                        orbitLabels.push(label);
                    }
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ –ø–æ–¥–ø–∏—Å–µ–π –∏ –ª–∏–Ω–∏–π –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Ä–æ–≤–Ω—è
            function updateOrbitActivity() {
                orbitLines.forEach(line => {
                    const level = line.userData.level;
                    line.material.opacity = level <= currentLevel ? 1.0 : 0.2;
                    line.material.transparent = true;
                });
                orbitLabels.forEach(label => {
                    const level = label.userData.level;
                    label.element.style.opacity = level <= currentLevel ? '1.0' : '0.2';
                });
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–æ–¥–ø–∏—Å–µ–π (—Å–∫—Ä—ã—Ç—ã –ª–∏ –∑–∞ –ø–ª–∞–Ω–µ—Ç–æ–π)
            function updateLabelsVisibility() {
                if (!sphereMesh) return;
                const spherePos = sphereMesh.position;
                const sphereRadius = SPHERE_RADIUS;
                const cameraPos = camera.position;
                
                orbitLabels.forEach(label => {
                    const worldPos = label.position.clone();
                    const direction = worldPos.clone().sub(cameraPos).normalize();
                    const distanceToPoint = cameraPos.distanceTo(worldPos);
                    
                    raycaster.set(cameraPos, direction);
                    const sphereIntersects = raycaster.intersectObject(sphereMesh);
                    
                    let hidden = false;
                    if (sphereIntersects.length > 0) {
                        const intersectDistance = sphereIntersects[0].distance;
                        if (intersectDistance < distanceToPoint - 0.1) {
                            hidden = true;
                        }
                    }
                    
                    label.visible = !hidden;
                });
            }
            
            // ==================== –°–õ–£–ß–ê–ô–ù–´–ï –†–ï–°–£–†–°–´ ====================
            function randomResources() {
                const res = [];
                for (let i = 0; i < MAX_LEVEL; i++) res.push({ presumed: Math.floor(Math.random()*5)+1, calculated: Math.floor(Math.random()*5)+1, proven: Math.floor(Math.random()*5)+1, current: Math.floor(Math.random()*5)+1, total: Math.floor(Math.random()*5)+1 });
                return res;
            }
            
            function updateStats() {
                const res = currentResources[currentLevel - 1];
                const star = (val) => { let s = ''; for (let i=0; i<val; i++) s += '<span style="color:#ffff88">‚òÖ</span>'; for (let i=val; i<5; i++) s += '<span style="color:#666666">‚òÜ</span>'; return s; };
                statsPanel.innerHTML = `
                    <div class="stat-item" title="–ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º—ã–µ —Ä–µ—Å—É—Ä—Å—ã"><span class="stat-label">üìä–ü–†–ï–î:</span><span class="stat-value">${star(res.presumed)}</span></div>
                    <div class="stat-item" title="–ü—Ä–æ—Å—á–∏—Ç–∞–Ω–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã"><span class="stat-label">üî¢–ü–†–û–°–ß:</span><span class="stat-value">${star(res.calculated)}</span></div>
                    <div class="stat-item" title="–î–æ–∫–∞–∑–∞–Ω–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã"><span class="stat-label">‚úÖ–î–û–ö:</span><span class="stat-value">${star(res.proven)}</span></div>
                    <div class="stat-item" title="–ò–∑—ã–º–∞–µ–º—ã–µ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å"><span class="stat-label">‚õè–ò–ó–´–ú:</span><span class="stat-value">${star(res.current)}</span></div>
                    <div class="stat-item" title="–í—ã—Ä–∞–±–æ—Ç–∞–Ω–æ –≤—Å–µ–≥–æ"><span class="stat-label">üè≠–í–´–†:</span><span class="stat-value">${star(res.total)}</span></div>
                    <div class="stat-item" title="–¢–µ–∫—É—â–∏–π —É—Ä–æ–≤–µ–Ω—å"><span class="stat-label">üåç–£–†–û–í:</span><span class="stat-value">${currentLevel}/${MAX_LEVEL}</span></div>
                    <div class="stat-item" title="–°—Ç–∞–Ω—Ü–∏–π –Ω–∞ –æ—Ä–±–∏—Ç–µ"><span class="stat-label">üõ∞Ô∏è–°–¢:</span><span class="stat-value">${stationsCount}/${MAX_STATIONS}</span></div>
                `;
                titleSpan.textContent = `–ü–õ–ê–ù–ï–¢–ê–†–ò–ô ‚Ä¢ ${currentPlanetType ? currentPlanetType.name : ''} –£–†.${currentLevel}`;
                aiDataDiv.textContent = JSON.stringify({ level: currentLevel, resources: res });
            }
            
            // ==================== –ì–ï–ù–ï–†–ê–¶–ò–Ø –ù–û–í–û–ô –ü–õ–ê–ù–ï–¢–´ ====================
            function generateNewPlanet() {
                // –û—á–∏—â–∞–µ–º —Å—Ç–∞–Ω—Ü–∏–∏ –ø—Ä–∏ —Å–º–µ–Ω–µ –ø–ª–∞–Ω–µ—Ç—ã (–∏–ª–∏ –æ—Å—Ç–∞–≤–ª—è–µ–º? –ª—É—á—à–µ —É–¥–∞–ª–∏—Ç—å)
                stations.forEach(s => {
                    planetGroup.remove(s.mesh);
                    planetGroup.remove(s.label);
                    planetGroup.remove(s.collider);
                });
                stations = [];
                stationsCount = 0;
                
                currentSeed = Date.now() + Math.floor(Math.random() * 1e6);
                const typeIndex = Math.floor(Math.random() * PLANET_TYPES.length);
                currentPlanetType = PLANET_TYPES[typeIndex];
                currentPalette = currentPlanetType.colors.slice();
                currentResources = randomResources();
                createSphere(currentSeed, currentPalette);
                createParticles(20000, currentPalette);
                const numTags = Math.floor(Math.random() * 11) + 5;
                createResourceTags(numTags);
                createOrbits();
                updateStats(); updateOrbitActivity();
            }
            
            function increaseLevel() { currentLevel = currentLevel < MAX_LEVEL ? currentLevel + 1 : 1; generateNewPlanet(); }
            function decreaseLevel() { currentLevel = currentLevel > 1 ? currentLevel - 1 : MAX_LEVEL; generateNewPlanet(); }
            
            // ==================== –°–û–ó–î–ê–ù–ò–ï –°–¢–ê–ù–¶–ò–ò ====================
            function createStation() {
                if (stationsCount >= MAX_STATIONS) {
                    fullMessageDiv.textContent = `‚ö†Ô∏è –õ–ò–ú–ò–¢ –°–¢–ê–ù–¶–ò–ô (${MAX_STATIONS})`;
                    fullMessageDiv.classList.add('show');
                    setTimeout(() => fullMessageDiv.classList.remove('show'), 1500);
                    return;
                }
                
                // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ –æ—Ä–±–∏—Ç–µ (—Ä–∞–¥–∏—É—Å —á—É—Ç—å –±–æ–ª—å—à–µ —Ç–µ–∫—É—â–µ–π –æ—Ä–±–∏—Ç—ã)
                const orbitRadius = BASE_RADIUS * Math.pow(GROWTH_FACTOR, currentLevel-1) + 2.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1); // —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –ø–æ —Å—Ñ–µ—Ä–µ
                const x = orbitRadius * Math.sin(phi) * Math.cos(theta);
                const y = orbitRadius * Math.sin(phi) * Math.sin(theta);
                const z = orbitRadius * Math.cos(phi);
                
                const pos = new THREE.Vector3(x, y, z);
                
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è –∏ –¥–∞–Ω–Ω—ã–µ
                const stationId = stationsCount + 1;
                const efficiency = Math.floor(Math.random() * 100);
                const power = Math.floor(Math.random() * 500) + 100;
                const data = {
                    id: stationId,
                    name: `ST-${stationId}`,
                    efficiency: efficiency,
                    power: power,
                    crew: Math.floor(Math.random() * 10) + 1
                };
                
                // –ú–∞–ª–µ–Ω—å–∫–∞—è —Å—Ñ–µ—Ä–∞ (—á–∞—Å—Ç–∏—Ü–∞)
                const sphereGeo = new THREE.SphereGeometry(0.15, 8, 8);
                const sphereMat = new THREE.MeshStandardMaterial({ color: 0x88ddff, emissive: 0x224466 });
                const mesh = new THREE.Mesh(sphereGeo, sphereMat);
                mesh.position.copy(pos);
                planetGroup.add(mesh);
                
                // CSS2D –º–µ—Ç–∫–∞
                const div = document.createElement('div');
                div.className = 'station-label';
                div.textContent = `${data.name} ‚ö°${data.efficiency}%`;
                const label = new THREE.CSS2DObject(div);
                label.position.copy(pos.clone().add(new THREE.Vector3(0.4, 0.4, 0.4)));
                planetGroup.add(label);
                
                // –ö–æ–ª–ª–∞–π–¥–µ—Ä –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
                const colliderGeo = new THREE.SphereGeometry(0.4, 6, 6);
                const colliderMat = new THREE.MeshBasicMaterial({ visible: false });
                const collider = new THREE.Mesh(colliderGeo, colliderMat);
                collider.position.copy(pos);
                collider.userData = { stationIndex: stations.length, type: 'station' };
                planetGroup.add(collider);
                
                stations.push({ mesh, label, collider, data });
                stationsCount++;
                
                updateStats();
            }
            
            // ==================== –ó–ê–ü–£–°–ö –í–´–†–ê–ë–û–¢–ö–ò (Ctrl+–¥–≤–æ–π–Ω–æ–π –∫–ª–∏–∫) ====================
            function startExtraction(tagIndex) {
                const tag = resourceTags[tagIndex];
                if (!tag) return;
                if (tag.userData.extractionActive) {
                    fullMessageDiv.textContent = '‚ö†Ô∏è –î–û–ë–´–ß–ê –£–ñ–ï –ò–î–Å–¢';
                    fullMessageDiv.classList.add('show');
                    setTimeout(() => fullMessageDiv.classList.remove('show'), 1500);
                    return;
                }
                
                const progressBar = tag.userData.progressElement;
                const duration = 600000; // 10 –º–∏–Ω—É—Ç –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
                const startTime = Date.now();
                
                tag.userData.extractionActive = true;
                tag.userData.extractionStart = startTime;
                
                const interval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const percent = Math.min(100, (elapsed / duration) * 100);
                    progressBar.style.width = percent + '%';
                    
                    if (elapsed >= duration) {
                        clearInterval(interval);
                        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –¥–æ–±—ã—á–∏: —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º total —Ä–µ—Å—É—Ä—Å–∞
                        if (currentResources[currentLevel-1].total < 5) {
                            currentResources[currentLevel-1].total++;
                        }
                        // –£–±–∏—Ä–∞–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
                        progressBar.style.width = '0%';
                        tag.userData.extractionActive = false;
                        tag.userData.extractionInterval = null;
                        updateStats();
                        
                        fullMessageDiv.textContent = `‚úÖ –í–´–†–ê–ë–û–¢–ö–ê –ó–ê–í–ï–†–®–ï–ù–ê (${tag.userData.resource})`;
                        fullMessageDiv.classList.add('show');
                        setTimeout(() => fullMessageDiv.classList.remove('show'), 2000);
                    }
                }, 1000);
                
                tag.userData.extractionInterval = interval;
                updateStats();
            }
            
            // ==================== –û–ë–†–ê–ë–û–¢–ß–ò–ö –î–í–ò–ñ–ï–ù–ò–Ø –ú–´–®–ò (—Ç—É–ª—Ç–∏–ø—ã) ====================
            function onMouseMove(event) {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –∫–æ–ª–ª–∞–π–¥–µ—Ä–∞–º–∏ —Ä–µ—Å—É—Ä—Å–æ–≤ –∏ —Å—Ç–∞–Ω—Ü–∏–π
                raycaster.setFromCamera(mouse, camera);
                
                // –°–Ω–∞—á–∞–ª–∞ —Ä–µ—Å—É—Ä—Å—ã
                const resIntersects = raycaster.intersectObjects(tagColliders);
                if (resIntersects.length > 0) {
                    const collider = resIntersects[0].object;
                    const tagIndex = collider.userData.tagIndex;
                    const tag = resourceTags[tagIndex];
                    if (tag) {
                        const data = tag.userData;
                        hoverTooltip.style.display = 'block';
                        hoverTooltip.style.left = (event.clientX + 20) + 'px';
                        hoverTooltip.style.top = (event.clientY - 40) + 'px';
                        hoverTooltip.innerHTML = `
                            <div style="border-bottom: 2px solid ${data.color}; margin-bottom: 5px; color: ${data.color};">${data.resource} (${data.amount} –µ–¥.)</div>
                            <table>
                                <tr><td style="color: #ffaa00;">üí∞ –¶–µ–Ω–∞:</td><td style="color: #ffff88;">${data.price} –∫—Ä./–µ–¥.</td></tr>
                                <tr><td style="color: #44aaff;">üì¶ –û–±—ä—ë–º:</td><td style="color: #88ccff;">${data.volume} —Ç—ã—Å. –º¬≥</td></tr>
                                <tr><td style="color: #33cc33;">‚ö° –°–∫–æ—Ä–æ—Å—Ç—å:</td><td style="color: #66ff66;">${data.rate} –µ–¥./—Å–µ–∫</td></tr>
                                <tr><td style="color: #ff8866;">‚¨á –ì–ª—É–±–∏–Ω–∞:</td><td style="color: #ffaa66;">${data.depth} –º</td></tr>
                                ${data.extractionActive ? '<tr><td style="color: #00ff00;" colspan="2">‚öôÔ∏è –î–û–ë–´–ß–ê...</td></tr>' : ''}
                            </table>
                        `;
                        return;
                    }
                }
                
                // –ó–∞—Ç–µ–º —Å—Ç–∞–Ω—Ü–∏–∏
                const stationIntersects = raycaster.intersectObjects(stations.map(s => s.collider));
                if (stationIntersects.length > 0) {
                    const collider = stationIntersects[0].object;
                    const stationIndex = collider.userData.stationIndex;
                    const station = stations[stationIndex];
                    if (station) {
                        const d = station.data;
                        hoverTooltip.style.display = 'block';
                        hoverTooltip.style.left = (event.clientX + 20) + 'px';
                        hoverTooltip.style.top = (event.clientY - 40) + 'px';
                        hoverTooltip.innerHTML = `
                            <div style="border-bottom: 2px solid #88ddff; color:#88ddff;">${d.name}</div>
                            <table>
                                <tr><td style="color: #ffaa00;">‚ö° –ö–ü–î:</td><td style="color: #ffff88;">${d.efficiency}%</td></tr>
                                <tr><td style="color: #44aaff;">üîã –ú–æ—â–Ω–æ—Å—Ç—å:</td><td style="color: #88ccff;">${d.power} –ú–í—Ç</td></tr>
                                <tr><td style="color: #33cc33;">üë• –≠–∫–∏–ø–∞–∂:</td><td style="color: #66ff66;">${d.crew}</td></tr>
                            </table>
                        `;
                        return;
                    }
                }
                
                hoverTooltip.style.display = 'none';
            }
            
            // ==================== –û–ë–†–ê–ë–û–¢–ß–ò–ö –î–í–û–ô–ù–û–ì–û –ö–õ–ò–ö–ê ====================
            function onDoubleClick(event) {
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ—Å—É—Ä—Å—ã
                const resIntersects = raycaster.intersectObjects(tagColliders);
                if (resIntersects.length > 0) {
                    const collider = resIntersects[0].object;
                    const tagIndex = collider.userData.tagIndex;
                    
                    if (event.ctrlKey) {
                        // Ctrl + –¥–≤–æ–π–Ω–æ–π –∫–ª–∏–∫: –∑–∞–ø—É—Å–∫ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–π –≤—ã—Ä–∞–±–æ—Ç–∫–∏
                        startExtraction(tagIndex);
                    } else {
                        // –û–±—ã—á–Ω—ã–π –¥–≤–æ–π–Ω–æ–π –∫–ª–∏–∫: –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–ø—É—Ç–Ω–∏–∫–∞ (–∫–∞–∫ –±—ã–ª–æ)
                        const tag = resourceTags[tagIndex];
                        if (!tag) return;
                        
                        if (satellites.some(s => s.tagIndex === tagIndex)) {
                            alert('–°–ø—É—Ç–Ω–∏–∫ —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∫ —ç—Ç–æ–º—É —Ä–µ—Å—É—Ä—Å—É.');
                            return;
                        }
                        
                        const satGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                        const satMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 });
                        const satMesh = new THREE.Mesh(satGeo, satMat);
                        satMesh.position.copy(tag.position.clone().add(new THREE.Vector3(0.5, 0.5, 0.5)));
                        planetGroup.add(satMesh);
                        
                        const timeoutId = setTimeout(() => {
                            const success = Math.random() > 0.5;
                            const amount = tag.userData.amount;
                            const resourceName = tag.userData.resource;
                            
                            if (success) {
                                if (currentResources[currentLevel-1].proven < 5) {
                                    currentResources[currentLevel-1].proven++;
                                }
                                updateStats();
                                alert(`–†–∞–∑–≤–µ–¥–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞! –û–±—ä—ë–º ${resourceName}: ${amount} –µ–¥.`);
                            } else {
                                alert(`–†–∞–∑–≤–µ–¥–∫–∞ –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞. –†–µ—Å—É—Ä—Å ${resourceName} –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω.`);
                            }
                            
                            planetGroup.remove(satMesh);
                            satellites = satellites.filter(s => s.timeout !== timeoutId);
                        }, 10000);
                        
                        satellites.push({ mesh: satMesh, tagIndex, timeout: timeoutId });
                    }
                    return;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞–Ω—Ü–∏–∏ (–º–æ–∂–Ω–æ —á—Ç–æ-—Ç–æ –¥–µ–ª–∞—Ç—å –ø—Ä–∏ –¥–≤–æ–π–Ω–æ–º –∫–ª–∏–∫–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä, —É–¥–∞–ª—è—Ç—å)
                const stationIntersects = raycaster.intersectObjects(stations.map(s => s.collider));
                if (stationIntersects.length > 0) {
                    const collider = stationIntersects[0].object;
                    const stationIndex = collider.userData.stationIndex;
                    const station = stations[stationIndex];
                    if (station && event.ctrlKey) {
                        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞–Ω—Ü–∏—é –ø—Ä–∏ Ctrl+–¥–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ (–¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è –º–µ—Å—Ç–∞)
                        planetGroup.remove(station.mesh);
                        planetGroup.remove(station.label);
                        planetGroup.remove(station.collider);
                        stations.splice(stationIndex, 1);
                        stationsCount--;
                        updateStats();
                    } else {
                        // –ü—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ —Ç—É–ª—Ç–∏–ø–µ (—É–∂–µ –µ—Å—Ç—å –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏)
                    }
                }
            }
            
            // ==================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ====================
            function init() {
                scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a0500);
                
                const aspect = canvasDiv.clientWidth / canvasDiv.clientHeight;
                camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
                camera.position.set(20, 10, 25);
                
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                renderer.setSize(canvasDiv.clientWidth, canvasDiv.clientHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                canvasDiv.appendChild(renderer.domElement);
                
                labelRenderer = new THREE.CSS2DRenderer();
                labelRenderer.setSize(canvasDiv.clientWidth, canvasDiv.clientHeight);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0';
                labelRenderer.domElement.style.left = '0';
                labelRenderer.domElement.style.pointerEvents = 'none';
                canvasDiv.appendChild(labelRenderer.domElement);
                
                const ambientLight = new THREE.AmbientLight(0x404060); scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1); dirLight.position.set(1, 2, 1); scene.add(dirLight);
                
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; controls.dampingFactor = 0.05; controls.autoRotate = false; controls.enableZoom = true; controls.maxPolarAngle = Math.PI / 2;
                
                scene.add(planetGroup);
                
                generateNewPlanet();
                
                document.getElementById('planetarium-add-btn').addEventListener('click', increaseLevel);
                document.getElementById('planetarium-reset-btn').addEventListener('click', decreaseLevel);
                document.getElementById('station-add-btn').addEventListener('click', createStation);
                
                titleSpan.addEventListener('contextmenu', (e) => { e.preventDefault(); tooltipDiv.classList.add('active'); setTimeout(() => tooltipDiv.classList.remove('active'), 2500); });
                
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                renderer.domElement.addEventListener('mouseleave', () => { hoverTooltip.style.display = 'none'; });
                renderer.domElement.addEventListener('dblclick', onDoubleClick);
                
                let clock = new THREE.Clock();
                function animate() {
                    requestAnimationFrame(animate);
                    controls.update();
                    updateLabelsVisibility();
                    renderer.render(scene, camera);
                    labelRenderer.render(scene, camera);
                }
                animate();
                
                window.addEventListener('resize', onWindowResize, false);
            }
            
            function onWindowResize() {
                camera.aspect = canvasDiv.clientWidth / canvasDiv.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvasDiv.clientWidth, canvasDiv.clientHeight);
                labelRenderer.setSize(canvasDiv.clientWidth, canvasDiv.clientHeight);
            }
            
            window.addEventListener('load', init);
        })();
    </script>
<script>
window._gs = null;
window.addEventListener('message', e => { if(e.data&&e.data.type==='game_state') window._gs=e.data.state; });
if(window.parent!==window) window.parent.postMessage({type:'get_state'},'*');
window.hubMsg = function(msg){ if(window.parent!==window) window.parent.postMessage(msg,'*'); };
</script>
</body>
</html>