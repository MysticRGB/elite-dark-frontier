<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10 –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–≤ ¬∑ 7 —Å—Ç–∞–¥–∏–π ¬∑ –º—è–≥–∫–∞—è –∫–∏—Å—Ç—å 150px</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        body { margin: 0; overflow: hidden; font-family: 'VT323', monospace; touch-action: none; color: #ffaa00; }
        #info {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(0,0,0,0.9); color: #ffdd88;
            padding: 12px 24px; border: 2px solid #ffaa00;
            font-size: 16px; pointer-events: none; z-index: 10;
            box-shadow: 0 0 15px rgba(255,170,0,0.3);
        }
        #info span { color: #ffff88; font-weight: bold; }
        #status {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.9); color: #ffdd88;
            padding: 10px 20px; border: 2px solid #ffaa00;
            font-size: 18px;
            box-shadow: 0 0 15px rgba(255,170,0,0.3);
            z-index: 30; cursor: pointer; user-select: none; transition: all 0.2s;
        }
        #status:hover { border-color: #ffff88; box-shadow: 0 0 25px rgba(255,170,0,0.5); }
        #progressPercent { color: #ffff88; font-weight: bold; }
        #levelDisplay { color: #88ff88; font-weight: bold; text-decoration: underline dotted; }
        #gradient-panel {
            position: absolute; top: 80px; right: 20px;
            background: rgba(0,0,0,0.9); border: 2px solid #ffaa00;
            padding: 15px; color: #ffdd88; width: 260px; z-index: 40;
            box-shadow: 0 0 15px rgba(255,170,0,0.3);
            max-height: calc(100vh - 120px); overflow-y: auto;
        }
        #gradient-panel h3 { margin: 0 0 12px 0; font-size: 18px; text-align: center; color: #ffff88; }
        .gradient-option { margin-bottom: 8px; display: flex; align-items: center; }
        .gradient-option input[type="radio"] { margin-right: 10px; accent-color: #88ccff; transform: scale(1.1); cursor: pointer; }
        .gradient-option label { cursor: pointer; font-size: 13px; }
        .gradient-option label:hover { color: #88ccff; }
        #instruction {
            position: absolute; bottom: 80px; left: 20px;
            background: rgba(0,0,0,0.6); color: #aaa;
            padding: 6px 15px; border-radius: 20px;
            font-size: 13px; border: 1px solid #333;
            backdrop-filter: blur(4px); z-index: 10;
        }
        .gradient-note {
            position: absolute; bottom: 30px; right: 30px;
            background: rgba(0,0,0,0.5); color: #aaa;
            padding: 8px 15px; border-radius: 20px;
            font-size: 13px; border: 1px solid #3a3a3a;
            backdrop-filter: blur(4px); z-index: 10;
        }
        /* –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–∏—Å—Ç–∏ */
        #brush-preview {
            position: absolute;
            pointer-events: none;
            border: 2px solid rgba(255,170,102,0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 50;
            box-shadow: 0 0 20px rgba(255,170,102,0.3);
        }
        #brush-preview::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 4px; height: 4px;
            background: rgba(255,170,102,0.9);
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div id="info">ü™® <span>–õ–ö–ú</span> ‚Äî –æ–±—Ä–∞–±–æ—Ç–∫–∞ (7 —Å—Ç–∞–¥–∏–π) ¬∑ <span>Ctrl+–º—ã—à—å</span> ‚Äî –∫–∏—Å—Ç—å ¬∑ <span>2x–∫–ª–∏–∫</span> –Ω–∞ —Å–æ—Å–µ–¥–Ω–∏–π ‚Äî –≤—ã–±—Ä–∞—Ç—å ¬∑ –í –°–æ–ª–Ω–µ—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ ‚âà1.1 –º–ª–Ω –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤</div>
    <div id="status">
        <span>–ø—Ä–æ–≥—Ä–µ—Å—Å: <span id="progressPercent">0%</span></span>&nbsp;&nbsp;|&nbsp;
        <span id="levelLabel">—É—Ä–æ–≤–µ–Ω—å: <span id="levelDisplay">1</span>/7</span>
    </div>
    <div id="gradient-panel">
        <h3>üé® 3D-–≥—Ä–∞–¥–∏–µ–Ω—Ç (–≤—ã–±–µ—Ä–∏ —Å—Ç–∏–ª—å)</h3>
        <div id="gradient-list"></div>
    </div>
    <div id="instruction">‚ú® –∑–∞–∂–º–∏ Ctrl –∏ –¥–≤–∏–≥–∞–π –º—ã—à—å—é ‚Äî –º—è–≥–∫–∞—è –∫–∏—Å—Ç—å 150px</div>
    <div class="gradient-note" id="gradientInfo">–≥—Ä–∞–¥–∏–µ–Ω—Ç: 1 —Ü–≤–µ—Ç</div>
    <div id="brush-preview"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==================== –ù–ê–°–¢–†–û–ô–ö–ò ====================
        const STAGES = 7;
        const BRUSH_RADIUS_PX = 150;
        const BASE_STEP = 1 / STAGES;
        const FALLOFF_EXP = 2;
        const START_LEVEL = 4; // –Ω–∞—á–∏–Ω–∞–µ–º —Å 4 ‚Äî —á—Ç–æ–±—ã –±—ã–ª–∏ –≤–∏–¥–Ω—ã —Ü–≤–µ—Ç–∞ —Å—Ä–∞–∑—É

        // ==================== –°–¶–ï–ù–ê ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(25, 15, 30);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 0);
        controls.maxPolarAngle = Math.PI;

        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(2, 3, 4);
        scene.add(dirLight);
        const backLight = new THREE.PointLight(0x446688, 0.8);
        backLight.position.set(-3, -1, -4);
        scene.add(backLight);

        // –ó–≤—ë–∑–¥—ã —Å –º–µ—Ä—Ü–∞–Ω–∏–µ–º
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 3000;
        const starPos = new Float32Array(starsCount * 3);
        const starSizes = new Float32Array(starsCount);
        const starPhases = new Float32Array(starsCount);
        for (let i = 0; i < starsCount; i++) {
            const r = 120 + Math.random() * 130;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            starPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            starPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            starPos[i*3+2] = r * Math.cos(phi);
            starSizes[i] = 0.15 + Math.random() * 0.4;
            starPhases[i] = Math.random() * Math.PI * 2;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        starsGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
        const starMat = new THREE.PointsMaterial({color: 0xaaccff, size: 0.3, transparent: true, opacity: 0.9});
        const stars = new THREE.Points(starsGeo, starMat);
        scene.add(stars);

        // –¢—É–º–∞–Ω–Ω–æ—Å—Ç–∏ (—Ü–≤–µ—Ç–Ω—ã–µ –¥–∞–ª—ë–∫–∏–µ –æ–±–ª–∞–∫–∞)
        for (let n = 0; n < 5; n++) {
            const nebGeo = new THREE.SphereGeometry(15 + Math.random()*20, 8, 8);
            const nebMat = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.5, 0.15),
                transparent: true, opacity: 0.08, wireframe: true
            });
            const neb = new THREE.Mesh(nebGeo, nebMat);
            neb.position.set((Math.random()-0.5)*200, (Math.random()-0.5)*200, (Math.random()-0.5)*200);
            scene.add(neb);
        }

        // –°–æ—Å–µ–¥–Ω–∏–µ –∞—Å—Ç–µ—Ä–æ–∏–¥—ã (–º–µ–ª–∫–∏–µ, –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–µ)
        const neighborAsteroids = [];
        const neighborColors = [0x886644, 0x664422, 0xaa8866, 0x998877, 0x776655, 0x554433];
        for (let na = 0; na < 6; na++) {
            const r = 20 + Math.random() * 25;
            const angle = (na / 6) * Math.PI * 2 + Math.random() * 0.4;
            const yOff = (Math.random() - 0.5) * 10;
            const nGeo = new THREE.IcosahedronGeometry(0.5 + Math.random() * 0.8, 1);
            const nPos = nGeo.attributes.position;
            for (let v = 0; v < nPos.count; v++) {
                const noise = 0.8 + Math.random() * 0.4;
                nPos.setXYZ(v, nPos.getX(v)*noise, nPos.getY(v)*noise, nPos.getZ(v)*noise);
            }
            nGeo.computeVertexNormals();
            const nMat = new THREE.MeshPhongMaterial({
                color: neighborColors[na], flatShading: true,
                wireframe: false, transparent: true, opacity: 0.7
            });
            const nMesh = new THREE.Mesh(nGeo, nMat);
            nMesh.position.set(Math.cos(angle)*r, yOff, Math.sin(angle)*r);
            nMesh.userData.neighborIndex = na;
            nMesh.userData.level = 1 + Math.floor(Math.random() * 7);
            nMesh.userData.gradient = Math.floor(Math.random() * 10);
            scene.add(nMesh);
            neighborAsteroids.push(nMesh);
            
            // wireframe overlay
            const wMat = new THREE.MeshBasicMaterial({color: neighborColors[na], wireframe: true, transparent: true, opacity: 0.3});
            const wMesh = new THREE.Mesh(nGeo, wMat);
            wMesh.position.copy(nMesh.position);
            scene.add(wMesh);
        }

        // –ö–ª–∏–∫ –ø–æ —Å–æ—Å–µ–¥–Ω–µ–º—É –∞—Å—Ç–µ—Ä–æ–∏–¥—É ‚Äî –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ
        const raycasterNeighbor = new THREE.Raycaster();
        renderer.domElement.addEventListener('dblclick', (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouseNDC = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            raycasterNeighbor.setFromCamera(mouseNDC, camera);
            const hits = raycasterNeighbor.intersectObjects(neighborAsteroids);
            if (hits.length > 0) {
                const hit = hits[0].object;
                currentGradientIndex = hit.userData.gradient;
                const radios = document.querySelectorAll('input[name="gradient"]');
                radios.forEach((r, i) => r.checked = (i === currentGradientIndex));
                createAsteroid(hit.userData.level);
                // –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
                hit.material.emissive = new THREE.Color(0xffaa00);
                setTimeout(() => { hit.material.emissive = new THREE.Color(0); }, 500);
            }
        });

        // ==================== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ====================
        let currentLevel = 1, asteroidMesh = null, wireframeMesh = null, geometry = null;
        let progress = null, vertexCount = 0, completed = false, colorStops = [];
        let outerRadius = 1.0, innerRadius = 1.0;
        const vec3 = new THREE.Vector3();
        const brushPreview = document.getElementById('brush-preview');

        // ==================== 10 –ì–†–ê–î–ò–ï–ù–¢–û–í ====================
        const gradientFunctions = [
            (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); return (outerRadius - r) / (outerRadius - innerRadius); },
            (x, y, z) => { const rx = Math.sqrt((x*x)*2 + (y*y)*1 + (z*z)*0.5); return (outerRadius - rx) / (outerRadius - innerRadius); },
            (x, y, z) => { const q = x*x + 2*y*y + 3*z*z; const maxQ = outerRadius*outerRadius * 3; return 1 - Math.sqrt(q / maxQ); },
            (x, y, z) => { const det = x*(z*z - x*x) - y*(y*z - x*y) + z*(y*x - z*z); const norm = Math.abs(det) / (outerRadius**3); return Math.min(1, norm); },
            (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const theta = Math.atan2(y, x); const phi = Math.acos(z / (r+0.001)); const spiral = (r - innerRadius) / (outerRadius - innerRadius) + 0.2 * theta / (2*Math.PI) + 0.1 * phi / Math.PI; return Math.min(1, Math.max(0, spiral % 1.0)); },
            (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); return 1 - (innerRadius / r); },
            (x, y, z) => { const trace = x*x + y*y + z*z + 2*(x*y + y*z + z*x); const maxTrace = 4 * outerRadius*outerRadius; return trace / maxTrace; },
            (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const nx = x/r, ny = y/r, nz = z/r; return (nx*0.5 + ny*0.3 + nz*0.2 + 1) / 2; },
            (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); return Math.sin(r*2) * 0.5 + 0.5; },
            (x, y, z) => { const a=1.5,b=1.0,c=0.7; const q = (x*x)/(a*a)+(y*y)/(b*b)+(z*z)/(c*c); return 1 - Math.sqrt(q)/2; }
        ];
        const gradientNames = ["–†–∞–¥–∏–∞–ª—å–Ω—ã–π","–≠–ª–ª–∏–ø—Å–æ–∏–¥–∞–ª—å–Ω—ã–π","–ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞—è","–î–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç–Ω—ã–π","–°–ø–∏—Ä–∞–ª—å–Ω—ã–π","–ì–∏–ø–µ—Ä–±–æ–ª–∏—á–µ—Å–∫–∏–π","–¢–µ–Ω–∑–æ—Ä –∏–Ω–µ—Ä—Ü–∏–∏","–£–≥–ª—ã –≠–π–ª–µ—Ä–∞","–ö—Ä–∏–≤–∏–∑–Ω–∞ (sin)","–ö–≤–∞–¥—Ä–∏–∫–∞"];
        let currentGradientIndex = 0;

        function computeT(x, y, z) {
            let t = gradientFunctions[currentGradientIndex](x, y, z);
            return Math.max(0, Math.min(1, t));
        }

        const keyColors = [
            { pos: 0.0, color: new THREE.Color(0x000000) },
            { pos: 0.25, color: new THREE.Color(0x0000ff) },
            { pos: 0.5, color: new THREE.Color(0x00ff00) },
            { pos: 0.75, color: new THREE.Color(0xffff00) },
            { pos: 1.0, color: new THREE.Color(0xff0000) }
        ];

        function generateColorStops(L) {
            const stops = [];
            for (let i = 0; i < L; i++) {
                const t = i / (L - 1);
                let j = 0;
                while (j < keyColors.length - 1 && keyColors[j+1].pos < t) j++;
                if (t <= keyColors[j].pos) stops.push(keyColors[j].color.clone());
                else if (t >= keyColors[keyColors.length-1].pos) stops.push(keyColors[keyColors.length-1].color.clone());
                else {
                    const left = keyColors[j], right = keyColors[j+1];
                    const localT = (t - left.pos) / (right.pos - left.pos);
                    stops.push(left.color.clone().lerp(right.color, localT));
                }
            }
            return stops;
        }

        function getColorByPosition(x, y, z) {
            const t = computeT(x, y, z);
            if (t <= 0) return new THREE.Color(0x000000);
            if (t >= 1) return colorStops[colorStops.length-1].clone();
            const index = Math.floor(t * (colorStops.length - 1));
            const nextIndex = Math.min(index + 1, colorStops.length - 1);
            const localT = (t - index / (colorStops.length - 1)) * (colorStops.length - 1);
            return colorStops[index].clone().lerp(colorStops[nextIndex], localT);
        }

        // ==================== –°–û–ó–î–ê–ù–ò–ï –ê–°–¢–ï–†–û–ò–î–ê ====================
        function createAsteroid(level) {
            if (asteroidMesh) { scene.remove(asteroidMesh); scene.remove(wireframeMesh); }
            currentLevel = level;
            innerRadius = 1.0;
            outerRadius = innerRadius * Math.pow(2, level);
            const detail = Math.min(level, 4);
            
            const baseGeo = new THREE.IcosahedronGeometry(1, detail);
            geometry = baseGeo.toNonIndexed();
            vertexCount = geometry.attributes.position.count;
            
            const dirArray = new Float32Array(vertexCount * 3);
            const posAttr = geometry.attributes.position;
            for (let i = 0; i < vertexCount; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                const x = posAttr.array[ix], y = posAttr.array[iy], z = posAttr.array[iz];
                const len = Math.sqrt(x*x + y*y + z*z);
                dirArray[ix] = x/len; dirArray[iy] = y/len; dirArray[iz] = z/len;
            }
            
            const outerPositions = new Float32Array(vertexCount * 3);
            const innerPositions = new Float32Array(vertexCount * 3);
            const noiseAmp = 0.3 * outerRadius;
            
            for (let i = 0; i < vertexCount; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                const dx = dirArray[ix], dy = dirArray[iy], dz = dirArray[iz];
                const theta = Math.acos(dy), phi = Math.atan2(dz, dx);
                const noise = Math.sin(theta*5)*Math.cos(phi*3)*1.2 + Math.sin(theta*12)*Math.sin(phi*5)*0.8 + Math.cos(theta*8+phi*2)*0.6;
                const rOuter = outerRadius + noise * noiseAmp;
                outerPositions[ix] = dx * rOuter; outerPositions[iy] = dy * rOuter; outerPositions[iz] = dz * rOuter;
                innerPositions[ix] = dx * innerRadius; innerPositions[iy] = dy * innerRadius; innerPositions[iz] = dz * innerRadius;
            }
            
            geometry.userData.outerPositions = outerPositions;
            geometry.userData.innerPositions = innerPositions;
            posAttr.array.set(outerPositions);
            posAttr.needsUpdate = true;
            
            progress = new Float32Array(vertexCount).fill(0);
            colorStops = generateColorStops(level);
            document.getElementById('gradientInfo').innerText = `–≥—Ä–∞–¥–∏–µ–Ω—Ç: ${level} —Ü–≤–µ—Ç–æ–≤`;
            
            const colors = new Float32Array(vertexCount * 3);
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            for (let i = 0; i < vertexCount; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                const col = getColorByPosition(outerPositions[ix], outerPositions[iy], outerPositions[iz]);
                colors[ix] = col.r; colors[iy] = col.g; colors[iz] = col.b;
            }
            geometry.attributes.color.needsUpdate = true;
            
            const material = new THREE.MeshPhongMaterial({ vertexColors: true, flatShading: true, side: THREE.DoubleSide, shininess: 15 });
            asteroidMesh = new THREE.Mesh(geometry, material);
            scene.add(asteroidMesh);
            
            const wireframeMat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, wireframe: true, transparent: true, opacity: 0.35 });
            wireframeMesh = new THREE.Mesh(geometry, wireframeMat);
            scene.add(wireframeMesh);
            
            completed = false;
            updateDisplay();
            
            // –ö–∞–º–µ—Ä–∞ —Å–Ω–∞—Ä—É–∂–∏ ‚Äî –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ø–æ–¥ —Ä–∞–∑–º–µ—Ä
            const camDist = outerRadius * 2.5 + 5;
            camera.position.set(camDist * 0.6, camDist * 0.4, camDist * 0.8);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        // ==================== –û–ë–ù–û–í–õ–ï–ù–ò–ï ====================
        function updatePositionsAndColors() {
            const posAttr = geometry.attributes.position;
            const posArray = posAttr.array;
            const colorAttr = geometry.attributes.color;
            const colorArray = colorAttr.array;
            const outerPositions = geometry.userData.outerPositions;
            const innerPositions = geometry.userData.innerPositions;
            
            for (let i = 0; i < vertexCount; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                const t = progress[i];
                posArray[ix] = outerPositions[ix] * (1-t) + innerPositions[ix] * t;
                posArray[iy] = outerPositions[iy] * (1-t) + innerPositions[iy] * t;
                posArray[iz] = outerPositions[iz] * (1-t) + innerPositions[iz] * t;
                const col = getColorByPosition(posArray[ix], posArray[iy], posArray[iz]);
                colorArray[ix] = col.r; colorArray[iy] = col.g; colorArray[iz] = col.b;
            }
            posAttr.needsUpdate = true;
            colorAttr.needsUpdate = true;
            geometry.computeVertexNormals();
            
            const allRed = progress.every(v => v >= 1.0 - 1e-9);
            if (allRed && !completed) {
                completed = true;
                asteroidMesh.material.emissive.setHex(0x335588);
                wireframeMesh.material.emissive.setHex(0x224488);
                wireframeMesh.material.color.setHex(0x88aaff);
            }
        }

        function updateColorsOnly() {
            const posArray = geometry.attributes.position.array;
            const colorArray = geometry.attributes.color.array;
            for (let i = 0; i < vertexCount; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                const col = getColorByPosition(posArray[ix], posArray[iy], posArray[iz]);
                colorArray[ix] = col.r; colorArray[iy] = col.g; colorArray[iz] = col.b;
            }
            geometry.attributes.color.needsUpdate = true;
        }

        function updateDisplay() {
            const avg = progress.reduce((a, b) => a + b, 0) / vertexCount;
            document.getElementById('progressPercent').innerText = Math.round(avg * 100) + '%';
            document.getElementById('levelDisplay').innerText = currentLevel;
        }

        // ==================== üé® –ú–Ø–ì–ö–ê–Ø –ö–ò–°–¢–¨ –° 7 –°–¢–ê–î–ò–Ø–ú–ò ====================
        function applySculptAtMouse(event) {
            if (completed) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            const mouseNDC = new THREE.Vector2(
                (screenX / rect.width) * 2 - 1,
                -(screenY / rect.height) * 2 + 1
            );
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouseNDC, camera);
            const intersects = raycaster.intersectObject(asteroidMesh);
            if (intersects.length === 0) return;
            
            const posArray = geometry.attributes.position.array;
            let affected = 0;
            
            for (let i = 0; i < vertexCount; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                vec3.set(posArray[ix], posArray[iy], posArray[iz]).project(camera);
                
                // NDC ‚Üí –ø–∏–∫—Å–µ–ª–∏
                const px = (vec3.x * 0.5 + 0.5) * rect.width;
                const py = (vec3.y * -0.5 + 0.5) * rect.height;
                
                const dx = px - screenX, dy = py - screenY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < BRUSH_RADIUS_PX) {
                    // üî• –ú—è–≥–∫–∏–π —Ñ–µ–π–¥: t¬≤ –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –∫—Ä–∞—è
                    const t = 1 - (dist / BRUSH_RADIUS_PX);
                    const falloff = Math.pow(t, FALLOFF_EXP);
                    
                    // üî• 7 —Å—Ç–∞–¥–∏–π: –∫–∞–∂–¥—ã–π –∫–ª–∏–∫ –¥–æ–±–∞–≤–ª—è–µ—Ç ~1/7, —É–º–Ω–æ–∂–µ–Ω–Ω–æ–µ –Ω–∞ falloff
                    progress[i] = Math.min(1.0, progress[i] + BASE_STEP * falloff);
                    affected++;
                }
            }
            
            if (affected > 0) {
                updatePositionsAndColors();
                updateDisplay();
                // –ß–∞—Å—Ç–∏—Ü—ã
                const hitPoint = intersects[0].point;
                const hitColor = getColorByPosition(hitPoint.x, hitPoint.y, hitPoint.z);
                for (let j = 0; j < 8; j++) spawnSculptParticle(hitPoint.clone().add(new THREE.Vector3((Math.random()-0.5)*0.3,(Math.random()-0.5)*0.3,(Math.random()-0.5)*0.3)), hitColor);
                // –≠–∫–æ–Ω–æ–º–∏–∫–∞
                if (window.hubMsg) {
                    window.hubMsg({type:'stat_increment', stat:'sculpted', amount:1});
                }
            }
        }

        // ==================== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò ====================
        renderer.domElement.addEventListener('click', (event) => {
            if (event.target.closest('#status') || event.target.closest('#gradient-panel')) return;
            applySculptAtMouse(event);
        });

        // Ctrl+mousemove –¥–ª—è —Å–∫—É–ª—å–ø—Ç–∏–Ω–≥–∞
        renderer.domElement.addEventListener('mousemove', (event) => {
            if (!event.ctrlKey) {
                brushPreview.style.display = 'none';
                return;
            }
            event.preventDefault();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∫–∏—Å—Ç–∏
            brushPreview.style.display = 'block';
            brushPreview.style.left = event.clientX + 'px';
            brushPreview.style.top = event.clientY + 'px';
            brushPreview.style.width = (BRUSH_RADIUS_PX * 2) + 'px';
            brushPreview.style.height = (BRUSH_RADIUS_PX * 2) + 'px';
            
            applySculptAtMouse(event);
        });

        // –°–∫—Ä—ã–≤–∞–µ–º –∫–∏—Å—Ç—å –ø—Ä–∏ –æ—Ç–ø—É—Å–∫–∞–Ω–∏–∏ Ctrl
        renderer.domElement.addEventListener('mouseleave', () => {
            brushPreview.style.display = 'none';
        });

        // –ö–ª–∏–∫ –ø–æ —Å—Ç–∞—Ç—É—Å—É ‚Äî —Å–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å
        document.getElementById('status').addEventListener('click', () => {
            let nextLevel = currentLevel % 7 + 1;
            createAsteroid(nextLevel);
        });

        // –†–∞–¥–∏–æ-–∫–Ω–æ–ø–∫–∏ –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–≤
        const gradientList = document.getElementById('gradient-list');
        gradientNames.forEach((name, index) => {
            const div = document.createElement('div');
            div.className = 'gradient-option';
            const radio = document.createElement('input');
            radio.type = 'radio'; radio.name = 'gradient'; radio.value = index; radio.id = `grad-${index}`;
            if (index === 0) radio.checked = true;
            radio.addEventListener('change', () => { currentGradientIndex = index; updateColorsOnly(); });
            const label = document.createElement('label');
            label.htmlFor = `grad-${index}`; label.textContent = name;
            div.appendChild(radio); div.appendChild(label);
            gradientList.appendChild(div);
        });

        // ==================== –ß–ê–°–¢–ò–¶–´ –ü–†–ò –°–ö–£–õ–¨–ü–¢–ò–ù–ì–ï ====================
        const sculptParticles = [];
        function spawnSculptParticle(pos, color) {
            const geo = new THREE.SphereGeometry(0.03, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 });
            const p = new THREE.Mesh(geo, mat);
            p.position.copy(pos);
            const dir = pos.clone().normalize();
            p.userData.vel = dir.multiplyScalar(0.05 + Math.random() * 0.1);
            p.userData.life = 1.0;
            scene.add(p);
            sculptParticles.push(p);
        }

        // –•—É–∫: –ø—Ä–∏ —Å–∫—É–ª—å–ø—Ç–µ ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –≤ —ç–∫–æ–Ω–æ–º–∏–∫—É
        const origApply = applySculptAtMouse;

        // ==================== –ó–ê–ü–£–°–ö ====================
        createAsteroid(START_LEVEL);

        let animTime = 0;
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            animTime += 0.016;
            
            // –ú–µ—Ä—Ü–∞–Ω–∏–µ –∑–≤—ë–∑–¥
            starMat.opacity = 0.7 + Math.sin(animTime * 0.5) * 0.2;
            const sizes = starsGeo.attributes.size.array;
            for (let i = 0; i < Math.min(300, starsCount); i++) {
                sizes[i] = starSizes[i] * (0.6 + Math.sin(animTime * 2 + starPhases[i]) * 0.4);
            }
            starsGeo.attributes.size.needsUpdate = true;
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –∑–≤—ë–∑–¥–Ω–æ–≥–æ —Ñ–æ–Ω–∞
            stars.rotation.y += 0.0001;
            stars.rotation.x += 0.00005;
            
            // –í—Ä–∞—â–µ–Ω–∏–µ —Å–æ—Å–µ–¥–Ω–∏—Ö –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
            neighborAsteroids.forEach((na, i) => {
                na.rotation.y += 0.002 + i * 0.001;
                na.rotation.x += 0.001;
                na.position.y += Math.sin(animTime * 0.5 + i) * 0.003;
            });
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —á–∞—Å—Ç–∏—Ü—ã
            for (let i = sculptParticles.length - 1; i >= 0; i--) {
                const p = sculptParticles[i];
                p.position.add(p.userData.vel);
                p.userData.life -= 0.02;
                p.material.opacity = p.userData.life;
                p.scale.multiplyScalar(0.97);
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    sculptParticles.splice(i, 1);
                }
            }
            
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        window.addEventListener('contextmenu', e => e.preventDefault());
    </script>
<script>
window._gs = null;
window.addEventListener('message', e => { if(e.data&&e.data.type==='game_state') window._gs=e.data.state; });
if(window.parent!==window) window.parent.postMessage({type:'get_state'},'*');
window.hubMsg = function(msg){ if(window.parent!==window) window.parent.postMessage(msg,'*'); };
</script>
</body>
</html>